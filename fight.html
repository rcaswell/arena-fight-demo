<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Example - example-interval-service-production</title>
  <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js"></script>  
</head>
<body ng-app="intervalExample">
  <script>
  angular.module('intervalExample', [])
    .controller('ExampleController', ['$scope', '$interval', '$rootScope', '$q',
      function ExampleController($scope, $interval, $rootScope, $q) {
        $scope.format = 'MMM dd, yyyy | h:mm a (ss) ';

		var players = [
			 new Player("Player 1", 100, 15, 10)
			,new Player("Player 2", 100, 15, 10)
			,new Player("Player 3", 100, 15, 10)
			,new Player("Player 4", 100, 15, 10)
		];
		
		$scope.players = players;
		$scope.logs = [];		   

        var stop;		
		
        $scope.fight = function() {
          // Don't start a new fight if we are already fighting
		  
			
			if ( angular.isDefined(stop) ) 
				return {
					getChampion : () => { return $scope.brackets.onChampionDeclared().then(onFinalistHandler).catch(onErrorHandler); },					
					getRunnerUp : () => { return $scope.brackets.onRunnerUpDeclared().then(onFinalistHandler).catch(onErrorHandler); },
					getBracketAWinner : () => { return $scope.brackets.onBracketAWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); },
					getBracketBWinner : () => { return $scope.brackets.onBracketBWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); }
				};
			
			stop = $interval(() => {		
			
				$scope.brackets.fight();
				if ($scope.brackets.isFinished()) $scope.stopFight();
				
			}, 100);
			
			return {
					getChampion : () => { return $scope.brackets.onChampionDeclared().then(onFinalistHandler).catch(onErrorHandler); },					
					getRunnerUp : () => { return $scope.brackets.onRunnerUpDeclared().then(onFinalistHandler).catch(onErrorHandler); },
					getBracketAWinner : () => { return $scope.brackets.onBracketAWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); },
					getBracketBWinner : () => { return $scope.brackets.onBracketBWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); }
				};
			
			function onFinalistHandler(player)
			{
				console.log(player); 
				return player; 
			}
			
			function onBracketHandler(result)
			{
				console.log("winner:= %s, loser:= %s", result.winner.Name, result.loser.Name)
				return result.winner;
			}
			
			function onErrorHandler(reason)
			{
				alert(reason); 
			}
        };
		

        $scope.stopFight = function() {
          if (angular.isDefined(stop)) {
            $interval.cancel(stop);
            stop = undefined;
          }
        };

        $scope.resetFight = function() {
			
			for (var idx = 0, max = players.length; idx < max; idx++)
			{
				players[idx].HP = 100;
			}
			
			$scope.brackets = null;			
        };

        $scope.$on('$destroy', function() {
          // Make sure that the interval is destroyed too
          $scope.stopFight();
        });
		
		$scope.Run = Run;
		
		var selectedPlayer;
		$scope.selectPlayer = (player) => {
			selectedPlayer = player;
			console.log(selectedPlayer);
		};
				
		$scope.brackets;
		
		function Run() {
			
			$scope.brackets = new Brackets();
			
			var promises = $scope.fight();
			
			promises.getChampion()
				.then(alertWinner.bind(this, "the final winner is "))
				.then(applyBonus);	
				
			promises.getRunnerUp()
				.then(alertWinner.bind(this, "the runnerup is "))
				.then(applyBonus);				
				
			promises.getBracketAWinner()
				.then(alertWinner.bind(this, "the winner of Bracket A is "));			
				
			promises.getBracketBWinner()
				.then(alertWinner.bind(this, "the winner of Bracket B is "));
			
			
			function alertWinner(prefix, player)
			{				
				if (player)
				{
					alert(prefix + player.Name);
					return { winner : player, bonus :  { ATK : 1, DEF : 0 }};
				} else {
					alert(prefix + "nobody... all dead!");
					return { winner : { ATK : 0, DEF : 0 }, bonus : { ATK : 0, DEF : 0 }};
				}
			}
			
			function applyBonus(data)
			{
				data.winner.ATK += data.bonus.ATK;
				data.winner.DEF += data.bonus.DEF;
			}
		}
		
		function Attack(attacker, target) {
			var currentHP = target.HP;
			target.HP = (attacker.ATK - target.DEF < 1) 
				  ? target.HP
				  : target.HP - (Math.floor(Math.random() * ((attacker.ATK - target.DEF) + 1)));
			$scope.logs.push(new log(attacker, target, currentHP - target.HP));
		}
		
		function log(attacker, target, amount){
			this.attacker = attacker;
			this.target = target;
			this.amount = amount;	
			this.isDead = target.HP < 1;
			if (this.isDead)
				this.target.state = "dead";
		}
		
		var availablePlayers = [];
		
		function setAvailabePlayers()
		{			
			for (var idx = 0, max = players.length; idx < max; idx++)
			{
				if (players[idx].HP > 0)
					availablePlayers.push(players[idx]);
			}
		}
		
		function getRandomPlayerFromQue()
		{
			var randomIndex = Math.floor(Math.random() * availablePlayers.length);
			var player = availablePlayers[randomIndex];
			availablePlayers.splice(randomIndex, 1);
			return player;
		}
		
		function Player(name, hp, atk, def) 
		{
			this.Name = name;
			this.MaxHP = hp;
			this.HP = hp;
			this.ATK = atk;
			this.DEF = def;
			this.state = "alive";
		}
		
		function Brackets()
		{
			setAvailabePlayers();
			
			this.BracketA = new Bracket(getRandomPlayerFromQue(), getRandomPlayerFromQue());
			this.BracketB = new Bracket(getRandomPlayerFromQue(), getRandomPlayerFromQue());						
			this.BracketC = null;
			
			var _deferredRunnerUpDeclared = $q.defer();
			var _deferredChampionDeclared = $q.defer();
			
			this.onChampionDeclared = () => {
				return _deferredChampionDeclared.promise;
			};
			
			this.onRunnerUpDeclared = () => {
				return _deferredRunnerUpDeclared.promise;
			};
			
			this.onBracketAWinnerDeclared = () => {
				return this.BracketA.onWinnerDeclared();
			}
			
			this.onBracketBWinnerDeclared = () => {
				return this.BracketB.onWinnerDeclared();
			}
			
			this.isFinished = () => {			
				return (this.BracketA.isFinished()) && (this.BracketB.isFinished()) && (this.BracketC != null && this.BracketC.isFinished());
			}
			
			this.fight = () => {			
				if (!this.BracketA.isFinished()) this.BracketA.fight();
				if (!this.BracketB.isFinished()) this.BracketB.fight();				
				if (this.BracketC != null && !this.BracketC.isFinished()) this.BracketC.fight();					
			}
			
			// assumes no ties
			var bracketWinners = [
				this.BracketA.onWinnerDeclared(), 
				this.BracketB.onWinnerDeclared()
			];
					
			$q.all(bracketWinners)
				.then((results) => {		
					this.BracketC = new Bracket(results[0].winner, results[1].winner);
					return this.BracketC;
				}).then((bracketC) => {
					return bracketC.onWinnerDeclared();
				}).then((finalist) => {
					_deferredRunnerUpDeclared.resolve(finalist.loser);
					_deferredChampionDeclared.resolve(finalist.winner);
				});			
		}
		
		function Bracket(homePlayer, awayPlayer)
		{
			var _homePlayer = homePlayer;
			var _awayPlayer = awayPlayer;
			
			this.round = 0;
			this.bracketPlayers = [_homePlayer, _awayPlayer];
									
			var _deferredWinner = $q.defer();
			var _deferredLoser = $q.defer();
			var _deferredTie = $q.defer();
			var _deferredFinish = $q.defer();
			
			this.isFinished = () => { 
				return (_homePlayer.HP < 1 || _awayPlayer.HP < 1); 
			};
			
			this.fight = () => {
				this.round += 1;
				
				Attack(_homePlayer, _awayPlayer);
				Attack(_awayPlayer, _homePlayer);		
				
				if (this.isFinished())
					declareFinish();
			};
			
			this.onFinishDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onWinnerDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onLoserDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onTieDeclared = () => {				
				return _deferredFinish.promise;
			};						
			
			var declareWinnerAndLoser = (winner, loser) =>
			{
				_deferredWinner.resolve( { winner : winner, rounds : this.round });
				_deferredLoser.resolve( { loser : loser, rounds : this.round });
			}
			
			var declareTie = () =>
			{
				_deferredTie.resolve({rounds : this.round});
			}
						
			var declareFinish = () =>
			{
				if (_homePlayer.HP > 0)
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : false, winner : _homePlayer, loser : _awayPlayer});
					declareWinnerAndLoser(_homePlayer, _awayPlayer);
				}
				else if (_awayPlayer.HP > 0)
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : false, winner : _awayPlayer, loser : _homePlayer});
					declareWinnerAndLoser(_awayPlayer, _homePlayer);
				}
				else
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : true, winner : null, loser : null});
					declareTie();
				}
			}		
		}
		
	  }])
    // Register the 'myCurrentTime' directive factory method.
    // We inject $interval and dateFilter service since the factory method is DI.
    .directive('myCurrentTime', ['$interval', 'dateFilter',
      function($interval, dateFilter) {
        // return the directive link function. (compile function not needed)
        return function(scope, element, attrs) {
          var format,  // date format
              stopTime; // so that we can cancel the time updates

          // used to update the UI
          function updateTime() {
            element.text(dateFilter(new Date(), format));
          }

          // watch the expression, and update the UI on change.
          scope.$watch(attrs.myCurrentTime, function(value) {
            format = value;
            updateTime();
          });

          stopTime = $interval(updateTime, 1000);

          // listen on DOM destroy (removal) event, and cancel the next UI update
          // to prevent updating time after the DOM element was removed.
          element.on('$destroy', function() {
            $interval.cancel(stopTime);
          });
        }
      }]);
</script>
<style>
	.logger > span {
		display: block;
		border-bottom: 0.1em solid silver;
		background-color: whitesmoke;
	}
	
	.playerInfo {
		display:inline-block;text-align:left;
		width:90%;
		background-color:whitesmoke;
		border:0.1em outset silver;
		padding:0.3em;
		cursor: pointer;
		margin-bottom:0.1em;
		position:relative;
		clear:both;
		overflow:hidden;
		font-size:16px;
		font-family: Calibri;
	}
	.playerInfo label {
		padding:0.01em 0.3em;
		display:inline-block;
	}
	.playerInfo span {
		display:inline-block;
	}
	
	.playerInfo:hover {
		background-color:white;
	}
	
	.playerInfo div {
		margin:0 auto;
		padding:0em;
		line-height:1em;
	}
	
	.playerInfo div.attributes {
		display:block;
		font-size:1.5em;
		line-height:1.3em;
	}
	
	.playerInfo.dead {
		background-color:red;
	}
	
	.playerInfoWrapper {display:inline-block; position:relative; clear:both; padding:0; margin:0;width:25%; text-align:center;}

</style>
<div>
  <div ng-controller="ExampleController">
    <label>Date format: <input ng-model="format"></label>
    <hr/>
    Current time is: <span my-current-time="format"></span>
    <hr/>
	<div class="playerInfoWrapper" ng-repeat="p in players track by p.Name">
		<div class="playerInfo {{p.state}}" ng-click="selectPlayer(p)">
			<div><label>Name</label><span>{{p.Name}}</span></div>
			<div><label>Health</label><span>{{p.HP}}/{{p.MaxHP}}</span></div>
			<div class="attributes">
				<label>Attack</label><span>{{p.ATK}}</span>
				<label>Defense</label><span>{{p.DEF}}</span>
			</div>
		</div>
	</div>
	<hr />
    <button type="button" ng-click="Run()">Fight</button>
    <button type="button" ng-click="stopFight()">StopFight</button>
    <button type="button" ng-click="resetFight()">resetFight</button>
	<hr />
	<div class="logger">
	<span ng-repeat="l in logs track by $index">
		{{l.attacker.Name}} hits {{l.target.Name}} for {{l.amount}} <span ng-show="{{l.isDead}}"> {{l.target.Name}} IS DEAD!!!</span>
	</span>
	</div>
  </div>
</div>
</body>
</html>

<!-- 
Copyright 2016 Google Inc. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
-->