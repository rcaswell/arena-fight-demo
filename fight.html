<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Example - example-interval-service-production</title>
  <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js"></script>  
</head>
<body ng-app="intervalExample">
  <script>
  angular.module('intervalExample', [])
    .controller('ExampleController', ['$scope', '$interval', '$rootScope', '$q',
      function ExampleController($scope, $interval, $rootScope, $q) {
        $scope.format = 'MMM dd, yyyy | h:mm a (ss) ';

		var players = [
			 new Player("Player 1", 100, 15, 10)
			,new Player("Player 2", 100, 15, 10)
			,new Player("Player 3", 100, 15, 10)
			,new Player("Player 4", 100, 15, 10)
			,new Player("Player 5", 100, 15, 10)
			,new Player("Player 6", 100, 15, 10)
			,new Player("Player 7", 100, 15, 10)
			,new Player("Player 8", 100, 15, 10)
			,new Player("Player 9", 100, 15, 10)
			,new Player("Player 10", 100, 15, 10)
		];
		
		$scope.players = players;
		$scope.logs = [];		   

        var stop;		
		
        $scope.fight = function() {
          // Don't start a new fight if we are already fighting
		  
			
			if ( angular.isDefined(stop) ) 
				return {
					getChampion : () => { return $scope.brackets.onChampionDeclared().then(onFinalistHandler).catch(onErrorHandler); },					
					getRunnerUp : () => { return $scope.brackets.onRunnerUpDeclared().then(onFinalistHandler).catch(onErrorHandler); },
					getBracketAWinner : () => { return $scope.brackets.onBracketAWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); },
					getBracketBWinner : () => { return $scope.brackets.onBracketBWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); }
				};
			
			stop = $interval(() => {		
			
				$scope.brackets.fight();
				if ($scope.brackets.isFinished()) $scope.stopFight();
				
			}, 100);
			
			return {
					getChampion : () => { return $scope.brackets.onChampionDeclared().then(onFinalistHandler).catch(onErrorHandler); },					
					getRunnerUp : () => { return $scope.brackets.onRunnerUpDeclared().then(onFinalistHandler).catch(onErrorHandler); },
					getBracketAWinner : () => { return $scope.brackets.onBracketAWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); },
					getBracketBWinner : () => { return $scope.brackets.onBracketBWinnerDeclared().then(onBracketHandler).catch(onErrorHandler); }
				};
			
			function onFinalistHandler(player)
			{
				console.log(player); 
				return player; 
			}
			
			function onBracketHandler(result)
			{
				console.log("winner:= %s, loser:= %s", result.winner.Name, result.loser.Name)
				return result.winner;
			}
			
			function onErrorHandler(reason)
			{
				alert(reason); 
			}
        };
		

        $scope.stopFight = function() {
          if (angular.isDefined(stop)) {
            $interval.cancel(stop);
            stop = undefined;
          }
        };

        $scope.resetFight = function() {
			
			for (var idx = 0, max = players.length; idx < max; idx++)
			{
				players[idx].HP = 100;
			}
			
			$scope.brackets = null;			
        };

        $scope.$on('$destroy', function() {
          // Make sure that the interval is destroyed too
          $scope.stopFight();
        });
		
		$scope.Run = Run;
		
		var selectedPlayer;
		$scope.selectPlayer = (player) => {
			selectedPlayer = player;
			console.log(selectedPlayer);
		};
				
		$scope.brackets;
		
		function Run() {
			
			$scope.brackets = new Brackets();
			
			var promises = $scope.fight();
			
			promises.getChampion()
				.then(alertWinner.bind(this, "the final winner is "))
				.then(applyBonus);	
				
			promises.getRunnerUp()
				.then(alertWinner.bind(this, "the runnerup is "))
				.then(applyBonus);				
				
			promises.getBracketAWinner()
				.then(alertWinner.bind(this, "the winner of Bracket A is "));			
				
			promises.getBracketBWinner()
				.then(alertWinner.bind(this, "the winner of Bracket B is "));
			
			
			function alertWinner(prefix, player)
			{				
				if (player)
				{
					alert(prefix + player.Name);
					return { winner : player, bonus :  { ATK : 1, DEF : 0 }};
				} else {
					alert(prefix + "nobody... all dead!");
					return { winner : { ATK : 0, DEF : 0 }, bonus : { ATK : 0, DEF : 0 }};
				}
			}
			
			function applyBonus(data)
			{
				data.winner.ATK += data.bonus.ATK;
				data.winner.DEF += data.bonus.DEF;
			}
		}
		
		function Attack(attacker, target) {
			var currentHP = target.HP;
			target.HP = (attacker.ATK - target.DEF < 1) 
				  ? target.HP
				  : target.HP - (Math.floor(Math.random() * ((attacker.ATK - target.DEF) + 1)));
			$scope.logs.push(new log(attacker, target, currentHP - target.HP));
		}
		
		function log(attacker, target, amount){
			this.attacker = attacker;
			this.target = target;
			this.amount = amount;	
			this.isDead = target.HP < 1;
			if (this.isDead)
				this.target.state = "dead";
		}
		
		var availablePlayers = [];
		
		function setAvailabePlayers()
		{			
			for (var idx = 0, max = players.length; idx < max; idx++)
			{
				if (players[idx].HP > 0)
					availablePlayers.push(players[idx]);
			}
		}
		
		function getRandomPlayerFromQue()
		{
			var randomIndex = Math.floor(Math.random() * availablePlayers.length);
			var player = availablePlayers[randomIndex];
			availablePlayers.splice(randomIndex, 1);
			return player;
		}
		
		function Player(name, hp, atk, def) 
		{
			this.Name = name;
			this.MaxHP = hp;
			this.HP = hp;
			this.ATK = atk;
			this.DEF = def;
			this.state = "alive";
		}
		
		function Brackets()
		{
			setAvailabePlayers();
			
			this.BracketA = new Bracket(getRandomPlayerFromQue(), getRandomPlayerFromQue());
			this.BracketB = new Bracket(getRandomPlayerFromQue(), getRandomPlayerFromQue());						
			this.BracketC = null;
			
			var _deferredRunnerUpDeclared = $q.defer();
			var _deferredChampionDeclared = $q.defer();
			
			this.onChampionDeclared = () => {
				return _deferredChampionDeclared.promise;
			};
			
			this.onRunnerUpDeclared = () => {
				return _deferredRunnerUpDeclared.promise;
			};
			
			this.onBracketAWinnerDeclared = () => {
				return this.BracketA.onWinnerDeclared();
			}
			
			this.onBracketBWinnerDeclared = () => {
				return this.BracketB.onWinnerDeclared();
			}
			
			this.isFinished = () => {			
				return (this.BracketA.isFinished()) && (this.BracketB.isFinished()) && (this.BracketC != null && this.BracketC.isFinished());
			}
			
			this.fight = () => {			
				if (!this.BracketA.isFinished()) this.BracketA.fight();
				if (!this.BracketB.isFinished()) this.BracketB.fight();				
				if (this.BracketC != null && !this.BracketC.isFinished()) this.BracketC.fight();					
			}
			
			// assumes no ties
			var bracketWinners = [
				this.BracketA.onWinnerDeclared(), 
				this.BracketB.onWinnerDeclared()
			];
					
			$q.all(bracketWinners)
				.then((results) => {		
					this.BracketC = new Bracket(results[0].winner, results[1].winner);
					return this.BracketC;
				}).then((bracketC) => {
					return bracketC.onWinnerDeclared();
				}).then((finalist) => {
					_deferredRunnerUpDeclared.resolve(finalist.loser);
					_deferredChampionDeclared.resolve(finalist.winner);
				});			
		}
		
		function Bracket(homePlayer, awayPlayer)
		{
			var _homePlayer = homePlayer;
			var _awayPlayer = awayPlayer;
			
			this.round = 0;
			this.bracketPlayers = [_homePlayer, _awayPlayer];
									
			var _deferredWinner = $q.defer();
			var _deferredLoser = $q.defer();
			var _deferredTie = $q.defer();
			var _deferredFinish = $q.defer();
			
			this.isFinished = () => { 
				return (_homePlayer.HP < 1 || _awayPlayer.HP < 1); 
			};
			
			this.fight = () => {
				this.round += 1;
				
				Attack(_homePlayer, _awayPlayer);
				Attack(_awayPlayer, _homePlayer);		
				
				if (this.isFinished())
					declareFinish();
			};
			
			this.onFinishDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onWinnerDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onLoserDeclared = () => {				
				return _deferredFinish.promise;
			};
			this.onTieDeclared = () => {				
				return _deferredFinish.promise;
			};						
			
			var declareWinnerAndLoser = (winner, loser) =>
			{
				_deferredWinner.resolve( { winner : winner, rounds : this.round });
				_deferredLoser.resolve( { loser : loser, rounds : this.round });
			}
			
			var declareTie = () =>
			{
				_deferredTie.resolve({rounds : this.round});
			}
						
			var declareFinish = () =>
			{
				if (_homePlayer.HP > 0)
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : false, winner : _homePlayer, loser : _awayPlayer});
					declareWinnerAndLoser(_homePlayer, _awayPlayer);
				}
				else if (_awayPlayer.HP > 0)
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : false, winner : _awayPlayer, loser : _homePlayer});
					declareWinnerAndLoser(_awayPlayer, _homePlayer);
				}
				else
				{
					_deferredFinish.resolve({rounds : this.round, wasTie : true, winner : null, loser : null});
					declareTie();
				}
			}		
		}
		
	  }])
    // Register the 'myCurrentTime' directive factory method.
    // We inject $interval and dateFilter service since the factory method is DI.
    .directive('myCurrentTime', ['$interval', 'dateFilter',
      function($interval, dateFilter) {
        // return the directive link function. (compile function not needed)
        return function(scope, element, attrs) {
          var format,  // date format
              stopTime; // so that we can cancel the time updates

          // used to update the UI
          function updateTime() {
            element.text(dateFilter(new Date(), format));
          }

          // watch the expression, and update the UI on change.
          scope.$watch(attrs.myCurrentTime, function(value) {
            format = value;
            updateTime();
          });

          stopTime = $interval(updateTime, 1000);

          // listen on DOM destroy (removal) event, and cancel the next UI update
          // to prevent updating time after the DOM element was removed.
          element.on('$destroy', function() {
            $interval.cancel(stopTime);
          });
        }
      }]);
</script>
<style>
	.logger > span {
		display: block;
		border-bottom: 0.1em solid silver;
		background-color: whitesmoke;
	}
	
	.playerInfo {
		display:inline-block;text-align:left;
		width:90%;
		background-color:whitesmoke;
		border:0.1em outset silver;
		padding:0.3em;
		cursor: pointer;
		margin-bottom:0.1em;
		position:relative;
		clear:both;
		overflow:hidden;
		font-size:16px;
		font-family: Calibri;
	}
	.playerInfo label {
		padding:0.01em 0.3em;
		display:inline-block;
	}
	.playerInfo span {
		display:inline-block;
	}
	
	.playerInfo:hover {
		background-color:white;
	}
	
	.playerInfo div {
		margin:0 auto;
		padding:0em;
		line-height:1em;
	}
	
	.playerInfo div.attributes {
		display:block;
		font-size:1.5em;
		line-height:1.3em;
	}
	
	.playerInfo.dead {
		background-color:red;
	}
	
	.playerInfoWrapper {display:inline-block; position:relative; clear:both; padding:0; margin:0;width:25%; text-align:center;}

</style>
<div>
  <div ng-controller="ExampleController">
    <label>Date format: <input ng-model="format"></label>
    <hr/>
    Current time is: <span my-current-time="format"></span>
    <hr/>
	<div class="playerInfoWrapper" ng-repeat="p in players track by p.Name">
		<div class="playerInfo {{p.state}}" ng-click="selectPlayer(p)">
			<div><label>Name</label><span>{{p.Name}}</span></div>
			<div><label>Health</label><span>{{p.HP}}/{{p.MaxHP}}</span></div>
			<div class="attributes">
				<label>Attack</label><span>{{p.ATK}}</span>
				<label>Defense</label><span>{{p.DEF}}</span>
			</div>
		</div>
	</div>
	<hr />
    <button type="button" ng-click="Run()">Fight</button>
    <button type="button" ng-click="stopFight()">StopFight</button>
    <button type="button" ng-click="resetFight()">resetFight</button>
	<hr />
	<div class="logger">
	<span ng-repeat="l in logs track by $index">
		{{l.attacker.Name}} hits {{l.target.Name}} for {{l.amount}} <span ng-show="{{l.isDead}}"> {{l.target.Name}} IS DEAD!!!</span>
	</span>
	</div>
  </div>
</div>
</body>
</html>

<!-- 
Copyright 2016 Google Inc. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
-->